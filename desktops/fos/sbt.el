(defun sbt-project-root (path)
  (while (and (not (file-exists-p (concat path "/project")))
              (not (equal path (file-truename (concat path "/..")))))
    (setf path (file-truename (file-truename (concat path "/..")))))
  (if (file-exists-p (concat path "/project")) path nil))

;; todo. this does not work. why?!
;;(set (make-local-variable 'sbt-invoke-XXX) YYY)
(if (not (boundp 'sbt-invoke-project)) (setq sbt-invoke-project (make-hash-table)))
(defun sbt-invoke-project () (gethash (buffer-name) sbt-invoke-project))
(defun set-sbt-invoke-project (value) (sethash (buffer-name) value sbt-invoke-project))
(if (not (boundp 'sbt-invoke-commands)) (setq sbt-invoke-commands (make-hash-table)))
(defun sbt-invoke-commands () (gethash (buffer-name) sbt-invoke-commands))
(defun set-sbt-invoke-commands (value) (sethash (buffer-name) value sbt-invoke-commands))
(if (not (boundp 'sbt-invoke-cont)) (setq sbt-invoke-cont (make-hash-table)))
(defun sbt-invoke-cont () (gethash (buffer-name) sbt-invoke-cont))
(defun set-sbt-invoke-cont (value) (sethash (buffer-name) value sbt-invoke-cont))
(if (not (boundp 'sbt-invoke-status)) (setq sbt-invoke-status (make-hash-table)))
(defun sbt-invoke-status () (gethash (buffer-name) sbt-invoke-status))
(defun set-sbt-invoke-status (value) (sethash (buffer-name) value sbt-invoke-status))
(if (not (boundp 'sbt-invoke-steps)) (setq sbt-invoke-steps (make-hash-table)))
(defun sbt-invoke-steps () (gethash (buffer-name) sbt-invoke-steps))
(defun set-sbt-invoke-steps (value) (sethash (buffer-name) value sbt-invoke-steps))
(if (not (boundp 'sbt-invoke-next-step)) (setq sbt-invoke-next-step (make-hash-table)))
(defun sbt-invoke-next-step () (gethash (buffer-name) sbt-invoke-next-step))
(defun set-sbt-invoke-next-step (value) (sethash (buffer-name) value sbt-invoke-next-step))
(if (not (boundp 'sbt-invoke-output-callback)) (setq sbt-invoke-output-callback (make-hash-table)))
(defun sbt-invoke-output-callback () (gethash (buffer-name) sbt-invoke-output-callback))
(defun set-sbt-invoke-output-callback (value) (sethash (buffer-name) value sbt-invoke-output-callback))

;; partially copy/pasted from ensime-sbt.el
(defun sbt-invoke (buffer-name project-name commands &optional cont)
  (let ((commands (if (stringp commands) (list commands) commands)))
  (when (and buffer-name project-name)
    (let ((target-buffer (get-buffer buffer-name)))
    (if target-buffer (kill-buffer target-buffer))
    (setq target-buffer (get-buffer-create buffer-name))
    (set-buffer target-buffer)
    
    ;; todo. this does not work. why?!
    ;;(set (make-local-variable 'sbt-invoke-project) project-name)
    ;;(set (make-local-variable 'sbt-invoke-commands) commands)
    ;;(set (make-local-variable 'sbt-invoke-cont) cont)
    ;;(set (make-local-variable 'sbt-invoke-status) nil)
    (set-sbt-invoke-project project-name)
    (set-sbt-invoke-commands commands)
    (set-sbt-invoke-cont cont)
    (set-sbt-invoke-status nil)

    (let ((target-window 
      (cond 
        ((and (boundp 'tool-buffers-display-in-bottom-window) tool-buffers-display-in-bottom-window)
         (if (top-window) (active-window)
         (if (bottom-window) (bottom-window) 
         (split-window-vertically))))
        ((and (boundp 'tool-buffers-display-in-right-window) tool-buffers-display-in-right-window)
         (if (left-window) (left-window)
         (if (right-window) (right-window) 
         (split-window-horizontally))))
        (t
         (active-window)))))
    (let ((pop-up-windows t)) (set-window-buffer target-window target-buffer))
    (select-window target-window)))

    (comint-mode)
    (set (make-local-variable 'comint-process-echoes) t)
    (set (make-local-variable 'comint-scroll-to-bottom-on-output) t)
    (set (make-local-variable 'comint-prompt-read-only) t)
    (set (make-local-variable 'ansi-color-for-comint-mode) t)
    (set (make-local-variable 'comint-output-index) 0)
    (set (make-local-variable 'comint-output-history) "")
    (set (make-local-variable 'comint-output-filter-functions) '(ansi-color-process-output comint-postoutput-scroll-to-bottom (lambda (chunk)
      (while (string-match ansi-color-regexp chunk)
        (setq chunk (replace-match "" nil t chunk)))
      (setq comint-output-history (concat comint-output-history chunk))

      (when (string-match "[ \t\r\n\v\f]+> $" comint-output-history)
        (let ((raw (replace-match "" nil t comint-output-history)))
        (let ((lines ()))
          (with-temp-buffer
            (insert raw)
            (goto-char (point-min))
            (while (not (eobp))
              (setq lines (append lines (list (chomp (thing-at-point 'line)))))
              (forward-line)))
          ;;(princ lines)
          ;;(princ (length lines))
          ;;(message (number-to-string comint-output-index))
          (setq comint-output-index (+ comint-output-index 1))
          (setq comint-output-history "")
          (if (functionp (sbt-invoke-output-callback)) (funcall (sbt-invoke-output-callback) lines))))))))

    (set (make-local-variable 'compilation-error-regexp-alist)
         '(("^\\[error\\] \\([_.a-zA-Z0-9 :\\\\/-]+[.]scala\\):\\([0-9]+\\):"
            1 2 nil 2 nil)))
    (set (make-local-variable 'compilation-mode-font-lock-keywords)
         '(("^\\[error\\] Error running compile:"
            (0 compilation-error-face))
           ("^.*\\*\\*\\* FAILED \\*\\*\\*"
            (0 compilation-error-face))
           ("^\\[warn\\][^\n]*"
            (0 compilation-warning-face))
           ("^\\(\\[info\\]\\)\\([^\n]*\\)"
            (0 compilation-info-face)
            (1 compilation-line-face))
           ("^\\[success\\][^\n]*"
            (0 compilation-info-face))))
    (compilation-shell-minor-mode t)

    (defvar sbt-minor-mode-map (make-keymap) "sbt-minor-mode keymap.")
    (define-key sbt-minor-mode-map (kbd "<tab>") 'compilation-next-error)
    (define-key sbt-minor-mode-map (kbd "<backtab>") 'compilation-previous-error)
    (define-key sbt-minor-mode-map (kbd "<return>") (lambda ()
      (interactive)
      (if (and (get-buffer-process (current-buffer)) (eq (point) (point-max)))
        (comint-send-input)
        (compile-goto-error))))
    (define-key sbt-minor-mode-map (kbd "C-S-r") (lambda () (interactive) (my-repl-project (sbt-invoke-project))))
    (define-key sbt-minor-mode-map (kbd "C-S-b") (lambda () (interactive) (my-compile-project (sbt-invoke-project))))
    (define-prefix-command 'sbt-minor-mode-compile-map)
    (define-key sbt-minor-mode-map (kbd "M-b") 'sbt-minor-mode-compile-map)
    (define-key sbt-minor-mode-compile-map (kbd "r") (lambda () (interactive) (my-rebuild-project (sbt-invoke-project))))
    (define-key sbt-minor-mode-compile-map (kbd "M-r") (lambda () (interactive) (my-rebuild-project (sbt-invoke-project))))
    (define-key sbt-minor-mode-map (kbd "<C-S-return>") (lambda () (interactive) (my-run-project (sbt-invoke-project))))
    (define-key sbt-minor-mode-map (kbd "<s-S-return>") (lambda () (interactive) (my-test-project (sbt-invoke-project))))
    (define-key sbt-minor-mode-map (kbd "q") (lambda () 
      (interactive)
      (if (and (get-buffer-process (current-buffer)) (eq (point) (point-max)))
        (insert "q")
        (bury-buffer))))
    (define-key sbt-minor-mode-map (kbd "g") (lambda () 
      (interactive)
      (if (and (get-buffer-process (current-buffer)) (eq (point) (point-max)))
        (insert "g")
        (sbt-invoke (buffer-name) (sbt-invoke-project) (sbt-invoke-commands) (sbt-invoke-cont)))))
    (define-minor-mode sbt-minor-mode "Hosts keybindings for sbt interactions" nil " sbt" 'sbt-minor-mode-map :global nil)
    (sbt-minor-mode 1)
    (defun my-minibuffer-setup-hook () (sbt-minor-mode 0))
    (add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

    ;; hello node.js => omg, I wish comint-send-input was synchronous!
    (set-sbt-invoke-next-step (lambda (&optional previous-step-output)
      ;;(message "sbt-invoke-next-step")
      ;;(princ previous-step-output)
      (let ((failed nil))
        (dolist (line previous-step-output) (if (string-match "^\\[error\\]" line) (setq failed t)))
        (when failed
          (set-sbt-invoke-status 'failed)
          ;; I don't kill SBT here, since it might be useful to leverage its Scala console
          (set-sbt-invoke-output-callback nil)
          (set-sbt-invoke-next-step nil)
          (goto-char (point-min))
          ;;(next-error 1))
          (next-error-no-select 1))
        (unless failed 
          (let ((next-step (car (sbt-invoke-steps))))
            (set-sbt-invoke-steps (cdr (sbt-invoke-steps)))
            (when next-step 
              (insert next-step)
              (comint-send-input))
            (unless (sbt-invoke-steps)
              (when (not (string= (car (last (sbt-invoke-commands))) "console"))
                (set-sbt-invoke-status 'success)
                (set-sbt-invoke-output-callback nil)
                (set-sbt-invoke-next-step nil)
                (comint-send-eof)
                ;; subsequent line is commented due to a bug in comint-output-filter
                ;; see the workaround below
                ;;(if (functionp (sbt-invoke-cont)) (funcall (sbt-invoke-cont)))
              )))))))
    (set-sbt-invoke-output-callback (sbt-invoke-next-step))

    ;; this works around a bug => comint-output-filter reports success incorrectly
    ;; though, now i don't have time to debug and correct that
    (set (make-local-variable 'after-change-functions) '((lambda (start stop prev-length) 
      (when (equal sbt-invoke-status 'success)
        (let ((content (buffer-substring-no-properties (point-min) (point-max))))
        (when (and (string-match "Process sbt finished" content)
                   (not (string-match "\\[error\\]" content)))
          (set-sbt-invoke-status nil)
          (set-sbt-invoke-output-callback nil)
          (set-sbt-invoke-next-step nil)
          (if (functionp (sbt-invoke-cont)) (funcall (sbt-invoke-cont)))))))))

    (set-sbt-invoke-steps sbt-commands)
    (cd (sbt-project-root sbt-path))
    (comint-exec (current-buffer) (buffer-name) "sbt" nil nil))))

(defadvice recompile (around override-recompile-for-sbt activate)
  (if (string= (buffer-name) "*sbt*")
    (sbt-invoke sbt-invoke-name sbt-invoke-path)
    ad-do-it))

(defadvice revert-buffer (around override-revert-for-sbt activate)
  (if (string= (buffer-name) "*sbt*")
    (sbt-invoke sbt-invoke-name sbt-invoke-path)
    ad-do-it))

;; no need to advice kill-buffer since it calls bury-buffer internally
(defadvice bury-buffer (around auto-kill-dedicated-sbt-window-on-bury activate)
  (let ((buffer-being-buried (buffer-name)))
  (let ((sole-window (sole-window)))
    (when (string= buffer-being-buried "*sbt*")
      (when (not sole-window)
        ;;(message (buffer-name (current-buffer)))
        (delete-window))
      (when sole-window 
        ad-do-it))
    (when (not (string= buffer-being-buried "*sbt*"))
      ad-do-it))))
